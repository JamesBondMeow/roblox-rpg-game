--[[
	ArmorLib
	
	ArmorLib is an item library that houses code that can be ran on the server relating
	to Armor, such as ArmorLib:Give(Player, Armor (ContentLib.Armor[...])), as well
	as equipping & unequipping armor, which is primarily ran through remotes fired from the 
	client's Inventory Gui.
]]

--> Services
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

--> References
local PlayerData = ReplicatedStorage:WaitForChild("PlayerData")

--> Dependencies
local ContentLibrary = require(ReplicatedStorage.Modules.Shared.ContentLibrary)
local EventModule = require(ReplicatedStorage.Modules.Shared.Event)

local Morph = require(ServerStorage.Modules.Server.Morph)
local CreateValue = require(ServerStorage.Modules.Server.createValue)
local RemoveValue = require(ServerStorage.Modules.Server.removeValue)

local GameConfig = require(ReplicatedStorage.GameConfig)

--> Variables
local Library = script.Name

local ArmorLib = {}
local ChangeCd = {}

--------------------------------------------------------------------------------

local function RequestCallback(Model, Name, CallbackType, Parameters)
	EventModule:Fire("ServerToServerEquipmentCallback", Model, Name, CallbackType, Parameters)
	EventModule:FireAllClients("ServerToClientEquipmentCallback", Model, Name, CallbackType, Parameters)
end

function ArmorLib:Give(Player: Player, Armor, DontSave, ShopBought, Amount)
	local pData = PlayerData:WaitForChild(Player.UserId, 5)
	
	local isItem = typeof(Armor) == "table" 
	if not isItem then
		warn(`Item {Library} --> {tostring(Armor) or "nil"} doesn't exist as a table, try using ContentLibrary.`)
		return
	end
	
	if pData then
		local Found = pData.Items[Library]:FindFirstChild(Armor.Name)
		
		local IsStackable = GameConfig.CanItemsStack or GameConfig.Categories[Library].IsStackable
		local CanGive = ((not Found) or IsStackable)
		
		local CanBuyMultiple = ShopBought == "Force" or (ShopBought and (not Armor.Config.Cost[4]) and IsStackable)
		if CanGive or CanBuyMultiple then
			CreateValue(pData, Armor, DontSave, Amount, Library)
			return true
		end
	else
		warn(("pData for Player '%s' doesn't exist! Did they leave?"):format(Player.Name))
	end
end

function ArmorLib:Trash(Player: Player, Armor, Amount)
	local pData = PlayerData:WaitForChild(Player.UserId, 5)
	
	if pData then
		RemoveValue(pData, Armor, Amount, Library)
		
		if pData.ActiveArmor.Value == Armor.Name then
			pData.ActiveArmor.Value = ""
			
			ArmorLib:UnequipArmor(Player)
		end
	else
		warn(("pData for Player '%s' doesn't exist! Did they leave?"):format(Player.Name))
	end
end

function ArmorLib:ClearStatistics(Statistics)
	for _, Statistic in Statistics:GetChildren() do
		for Name, Value in Statistic:GetAttributes() do
			if string.find(Name, "Armor") then
				Statistic:SetAttribute(Name, nil)
			end
		end
	end
end

function ArmorLib:ClearBoosts(Boosts)
	for _, Boost in GameConfig.ClassBoosts do
		local Value = Boosts[Boost]
		Value:SetAttribute("Armor", nil)
		Value:SetAttribute("ArmorAdditive", nil)
	end
end

function ArmorLib:EquipArmor(Player: Player, Armor)
	local Character = Player.Character
	
	local Humanoid = Character and Character:FindFirstChild("Humanoid")
	local Attributes = Humanoid and Humanoid:WaitForChild("Attributes", 1)
	if not Attributes or Humanoid.Health <= 0 then return end
	
	-- Humanoid changes
	Attributes.Health:SetAttribute("Armor", Armor.Config.Health)
	Attributes.WalkSpeed:SetAttribute("Armor", Armor.Config.WalkSpeed)
	Attributes.JumpPower:SetAttribute("Armor", Armor.Config.JumpPower)
	
	-- Mana/Data changes
	local Boosts = Humanoid:WaitForChild("Boosts")
	ArmorLib:ClearBoosts(Boosts)
	
	if Armor.Config.Mana then
		local ManaAttributes = Humanoid:WaitForChild("Mana")
		ManaAttributes.MaxMana:SetAttribute("Armor", Armor.Config.Mana)
	end
	
	if Armor.Config.DamageClass then
		local DamageClass = Armor.Config.DamageClass
		
		local DamagePoints = Armor.Config.DamagePoints[1]
		local Additive = Armor.Config.DamagePoints[2]
		
		Boosts[DamageClass]:SetAttribute((Additive and "ArmorAdditive") or Additive, DamagePoints)
	end
	
	-- Statistics changes
	local Statistics = Humanoid.Statistics
	ArmorLib:ClearStatistics(Statistics)
	
	for _, Attribute in Statistics:GetChildren() do
		local Value = Armor.Config[Attribute.Name]
		if not Value then
			continue
		end
		
		local IsAdditive = Value[2]
		Attribute:SetAttribute((IsAdditive and "ArmorAdditive") or "Armor", Value[1])
	end
	
	-- Morph changes
	Morph:ApplyOutfit(Player, Armor)
	RequestCallback(Armor.Instance, Armor.Name, "OnEquipped", {Player, Armor.Config})
end

function ArmorLib:UnequipArmor(Player: Player)
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChild("Humanoid")
	
	local pData = PlayerData:WaitForChild(Player.UserId)
	local Armor = ContentLibrary[Library][pData.ActiveArmor.Value]
	RequestCallback(Armor.Instance, Armor.Name, "OnUnequipped", {Player, Armor.Config})
	
	-- Humanoid changes
	local Attributes = Humanoid and Humanoid:FindFirstChild("Attributes")
	if Attributes then
		Attributes.Health:SetAttribute("Armor", nil)
		Attributes.WalkSpeed:SetAttribute("Armor", nil)
		Attributes.JumpPower:SetAttribute("Armor", nil)
	end
	
	-- Boost/mana changes
	local Boosts = Humanoid and Humanoid:FindFirstChild("Boosts")
	if Boosts then
		ArmorLib:ClearBoosts(Boosts)
	end
	
	local ManaAttributes = Humanoid and Humanoid:FindFirstChild("Mana")
	if ManaAttributes then
		ManaAttributes.MaxMana:SetAttribute("Armor", nil)
	end
	
	-- Statistics changes
	local Statistics = Humanoid and Humanoid:FindFirstChild("Statistics")
	if Statistics then
		ArmorLib:ClearStatistics(Statistics)
	end
	
	-- Morph changes
	Morph:ClearOutfit(Player)
end

--------------------------------------------------------------------------------

local ArmorContent = {}

-- Armor objects
local function AddArmorToContent(ArmorInstance)
	local Config = require(ArmorInstance:FindFirstChildWhichIsA("ModuleScript"))
	
	if ArmorContent[Config.Name] then
		warn(`Armor {Config.Name} already exists in ArmorContent, please change its name.`)
		return
	end
	
	ArmorContent[Config.Name] = Config
end

for _, ArmorInstance in CollectionService:GetTagged("Armor") do
	task.spawn(AddArmorToContent, ArmorInstance)
end

CollectionService:GetInstanceAddedSignal("Armor"):Connect(AddArmorToContent)

-- Remotes
local function RequestUnequipArmor(Player)
	local pData = PlayerData:WaitForChild(Player.UserId)
	
	ArmorLib:UnequipArmor(Player)
	pData.ActiveArmor.Value = ""
end

local function RequestEquipArmor(Player, ArmorName: string)
	if typeof(ArmorName) ~= "string" then return end
	
	local pData = PlayerData:WaitForChild(Player.UserId)
	
	local ArmorValue = pData.Items.Armor:FindFirstChild(ArmorName)
	local ArmorItem = ContentLibrary.Armor[ArmorName]

	if ArmorValue and ArmorItem and not ChangeCd[Player.UserId] then
		ChangeCd[Player.UserId] = true
		task.delay(0.25, function()
			ChangeCd[Player.UserId] = nil
		end)

		ArmorLib:EquipArmor(Player, ArmorItem)
		pData.ActiveArmor.Value = ArmorName
	end
end

EventModule:GetOnServerEvent("EquipObjectArmor"):Connect(function(Player, ArmorName: string)
	if typeof(ArmorName) ~= "string" then return end
	
	local ArmorConfig = ArmorContent[ArmorName]
	local Requirements = ArmorConfig and ArmorConfig.Requirements
	if not Requirements then return end
	
	local pData = PlayerData:WaitForChild(Player.UserId)
	local Level = pData:WaitForChild("Stats"):WaitForChild("Level")
	if Requirements.Level and Level.Value < Requirements.Level then
		return
	end
	
	local ArmorFolder = pData:WaitForChild("Items"):WaitForChild("Armor")
	if Requirements.DataValue and not ArmorFolder:FindFirstChild(ArmorName) then
		return
	end
	
	local ArmorItem = ContentLibrary.Armor[ArmorName]
	if ArmorItem then
		if not ArmorFolder:FindFirstChild(ArmorName) then
			ArmorLib:Give(Player, ArmorItem)
		end

		RequestEquipArmor(Player, ArmorName)
	end
end)

EventModule:GetOnServerEvent("UnequipObjectArmor"):Connect(RequestUnequipArmor)
EventModule:GetOnServerInvoke("EquipArmor", RequestEquipArmor)
EventModule:GetOnServerInvoke("UnequipArmor", RequestUnequipArmor)

--------------------------------------------------------------------------------

local function OnPlayerAdded(Player: Player)
	local pData = PlayerData:WaitForChild(Player.UserId)
	
	local function OnCharacterAdded(Character)
		local ActiveArmor = pData:WaitForChild("ActiveArmor")
		local Armor = ActiveArmor.Value ~= "" and ContentLibrary.Armor[ActiveArmor.Value]
		
		-- Update any incoming accessories (CharacterAppearanceLoaded is really broken lol)
		local Connection = Character.ChildAdded:Connect(function(Child)
			if Child:IsA("Accessory") then
				Morph:UpdateAccessoriesTransparency(Character, ActiveArmor.Value ~= "" and ContentLibrary.Armor[ActiveArmor.Value])
			end
		end)
		Player.CharacterRemoving:Once(function()
			Connection:Disconnect()
		end)
		
		if Armor then
			if Player:HasAppearanceLoaded() then
				ArmorLib:EquipArmor(Player, Armor)
			else
				Player.CharacterAppearanceLoaded:Once(function()
					ArmorLib:EquipArmor(Player, Armor)
				end)
			end
		end
	end
	
	Player.CharacterAdded:Connect(OnCharacterAdded)
	if Player.Character then
		OnCharacterAdded(Player.Character)
	end
end

for _, Player in Players:GetChildren() do
	task.defer(OnPlayerAdded, Player)
end
Players.PlayerAdded:Connect(OnPlayerAdded)
return ArmorLib
